	In primul rand programul este structurat astfel: cel principal 'tema2.c' si 4 headers, fiecare cu rolul lui:
	-task.h: aici sunt majoritatea functiilor care se ocupa de rezolvarea cerintelor + o functie ajutatoare. Cele care se ocupa de rezolvarea cerintelor vor fi explicate fiecare in parte cand se ajunge la explicarea rezolvarii cerintelor. In schimb functia ajutatoare este "divideCheck" care primeste matricea de pixeli si zona in care trebuie sa calculeze 'mean'-ul(zona este primita ca 2 coordonate 'x' si 'y' care reprezinta coltul din stanga sus al zonei si 'dim' care reprezinta dimensiunea zonei, care este patratica), care este calculat conform formulei primite in enunt: prima oara se calculeaza media pentru culorile 'red', 'green' si 'blue' a pixelilor din zona si dupa se calculeaza suma finala si se imparte la '3 * dim * dim', reprezentand 'mean'-ul. Daca acesta este mai mic sau egal cu pragul, atunci nodul se considera frunza si se atribuie la 'elem.poz' valoarea 1, daca nu nodul se considere intern si i se atribuie valoarea 0 si apoi se returneaza elementul de tip 'Item';
	-element.h: aici se afla structura pentru un pixel cu culorile 'red', 'green' si 'blue', salvate ca unsigned char si o structura numita 'Item' care este folosita pentru a salva elementele in arbor si cuprinde felul nodului(intern sau frunza) si un element de tip pixel. Pe langa acestea se afla si o functie de a crea un element 'Item' cu toate valorile 0 si functiile de prelucrarea a matricei de pixeli: "alocMatrice" care aloca memorie unei matrice de dimensiuni 'dim' * 'dim'(prima oara aloca 'dim' pointeri de struct 'Pix' si dupa aloca pentru fiecare linie inca 'dim' structuri de tip 'Pix'), "citireMatrice" care citeste matricea din fisierul binar pixel cu pixel cu fread, citind la fiecare pixel culorile 'red', 'green' si 'blue' cu dimensiunea 'unsigned char', "citireFisierMatrice" care citeste intregul fisier de tip 'ppm' prima oara citind faptul ca este de tip 'P6' si endline-ul, apoi dimesniune matricii si dupa restul caracterelor pana la matricea de pixeli in sine(cealalta dimensiune, care nu este necesara ca se garanteaza matrici patratice si valoarea maxima din cadrul elementelor care iar nu e necesara ca se garanteaza ca mereu va fi 255), "afisareMatrice" care este o functie pentru testare si afiseaza valorile pixelilor matricei ca unsigned int intr-un fisier text, "scriereMatrice" care scrie pe o portiune data in matrice valoarea pixelui dat ca argument si "destroyMatrice" care dezaloca memoria matricei, prima oara dezalocand liniile si abia dupa toata matricea;
	-arbori.h: aici se afla structurile si functiile care se ocupa de crearea si prelucrarea arborilor cuatrenari. Structura 'Tree' este folosita pentru a retine un nod al arborelui si contine: 2 coordonate 'x', 'y' si o dimensiune pentru a sti zona din matricea de pixeli pentru care se va calcula 'mean'-ul nodului respectiv, unde 'x' si 'y' reprezinta coltul din stanga sus al zonei de dimensiune 'dim' * 'dim'(in caz ca este cerinta 1 sau 2), un element de tip 'Item' a carui structura se afla in 'element.h' si cei 4 fii ai nodului(top_left, top_right, bottom_right si bottom_left). Prima functie este 'createTree' care aloca memorie pentu un nod al arborelui si ii initiaza valorile cu cele primite ca argument sau cu NULL, dupa este functia 'initTree' care doar creeaza radacina intregului arbore. Functia 'maxValue' este una ajutatoare doar, care returneaza valoarea maxima dintre 4 valori intregi. Functia 'height' initial doar calcula inaltimea arborelui pentru testare, dar mai tarziu a fost modificata pentru aflarea fiecarei valori cerute la cerinta 1(va vi explicata cand se va explica rezolvarea cerintei 1). La final este functa "destroyTree" care se ocupa de dezalocarea intregului arbore;
	-coada.h: se ocupa de structuri si functii pentru o coada, aici se afla struct-ul 'CoadaNodes' care contine un nod din arbore si urmatorul nod din coada. Aceasta coada este folosita pentru parcugerea in latime a arborelui cuatrenar in cadrul rezolvarii cerintei 2 si de crearea acestuia tot in latime in cadrul cerintei 3. Mai contine si functia "isCoadaEmpty" care verifica daca coada este goala. Pe langa acestea se mai afla o structura pentru retinerea cozii, care retine adresele celor 2 capete ale cozii, o functie care aloca memorie pentru un nod si initializeaza valorile acestuia cu valorile primite ca argument, o functie care aloca memorie pentru toata coada si initializeaza capetele cu NULL, o functie care adauga un element in capatul cozii, prima oara alocand memorie pentru un nod si dupa verificand daca coada este goala, in caz afirmativ punandu-l in ambele capete, iar daca nu adaugandu-l dupa ultimul nod si schimband apoi capatul, o functie care sterge primul element din coada(nu se mai verifica daca coada este goala sau nu deoarece cerinta ne asigura ca nu ar trebui sa intampinam cazul de scoatere a unui elemet cand coada este goala) si se elibereaza memoria a nodului sters si o functie de eliberare a memoriei pentru fiecare element din coada apoi a intregii cozi;
	Pe langa functiile si stucturile din headere, in 'tema2.c' se afla structura 'Args' care retine valorille primite ca argument, functia "citireArgs" care initializeaza o varibila de tip Args. Aceasta functie a fost creata initial cu gandul ca se pot cere mai multe cerinte intr-o singura rulare a programului, astfel initial se atribuie la toate valorile din 'task' valoarea 0 si dupa se verifica daca primul cuvant are caracterul '-'. Daca da, atunci inseamna ca cuvantul respectiv indica cerinta care trebuie rezolvata. In caz ca e cerinta 1 sau 2, dupa ce li se atribuie variabilelor 'task.c1' sau 'task.c2' valoarea 1 se atribuie si pragul la 'task.prag1' si/sau 'task.prag2'. Daca este caracterul 'd' dupa '-', sau cerinta 3 doar se atribuie la 'task.d' 1 si se scade i-ul cu care se parcug string-urile din 'argv'(daca se afla '-d', fisierul de intrare va fi pe o pozitie cu valoare para in argv, daca nu se va afla pe o pozitie cu valoare impara). Se stie ca pot fi maxim 3 cerinte, deci maxim 5 cuvinte(3 de la cate cerinta trebuie rezolvata si 2 de la praguri) deci daca contorul a depasit 5, sau cuvantul nu are caracterul '-' se stie ca s-a ajuns la fisierul de intrare si dupa cel de iesire, deci se salveaza in 'task.in', respectiv 'task.out' cele 2 fisiere si la final de tot se returneaza 'task'.
	Majoritatea functiilor auxiliare fiind prezentate, putem intra in main. Aici prima oara apelam "citireArgs" sa stim ce avem de facut, dupa se vede pe ce caz suntem:
	-cerinta 1: prima oara se citeste fisierul de tip 'ppm' cu "citireFisierMatrice" si se salveaza matricea de pixeli in 'mat', dua se initializeaza arborele cuatrenar 'root' si dupa se apeleaza functia de comprimare a imaginii "compresion" din 'task.h', care prima oara verifica daca nodul mai trebuie divizat sau nu in 4 fii, adica daca este intern sau nu apeland functia 'divideCheck'. In caz ca este frunza doar se atribuie acelui nod valorile obtinute in momentul calcularii 'mean'-ului, in caz ca este intern se initializeaza cei 4 fii ai nodului si apoi pentru fiecare in parte se apeleaza recursiv "compresion" (pentru ambele lucruri se face in ordinea aceasta: top_left, top_right, bottom_right, bottom_left). Apoi ne intoarcem in "main" unde apelam "destryMatrice" pentru a dezaloca matricea de pixeli caci nu mai avem nevoie de aceasta. Dupa se apeleaza "height", care calculeaza inaltimea arborelui, numarul de frunze a arborelui sau zonele nedivizate si zona maxima nedivizata. Aceste lucruri se fac recursiv, returnandu-se inaltimea maxima a celor 4 fii ai nodului prin apelul functie si numarul de frunze si dimensiunea maxima prin antetul functiei. Astfel cand se intalneste un nod de tip frunza, sau cu variabila 'elem.poz' egala cu valoarea 0 se vede daca dimensiunea zonei din matricea de pixeli pe care o reprezinta este mai mare decat maximul, daca da se schimba maximul, dupa se creste contorul de frunze si la final se returneaza valoare 0. Daca nu este nod frunza, atunci este intern si se calculeaza maximul dintre cei 4 fii si se returneaza aceasta valoare + 1. Dupa ce se iese de tot din "height" se scriu aceste valori in fisierul text si se dezaloca memoria arborelui;
	-cerinta 2: se citeste fisierul binar, se face compresia si se dezaloca matricea ca in cerinta 1. Apoi se initializeaza coada de noduri de arbore si se pune radacina arborelui in coada. Se scrie in fisierul binar dimensiunea matricii si se intra in functia "writeCompressed", unde se face parcugerea arborului in latime si se scrie fisierul comprimat astfel: se intra intr-un while care se va executa pana cand coada ramane goala. In while prima oara verificam daca nodul arborelui salvat in capul cozii este valid, adica diferit de NULL. Daca da, se verifica de ce tip nodul arborelui salvat in capul cozii, daca este intern, adica are variabila 'elem.poz' egala cu valoarea 0, atunci se scrie doar aceasta valoare in fisier, daca este de tip frunza, atunci se scrie valoarea variabile 'elem.poz' a nodului de arbor salvat in capul cozii, care in cazul acesta o sa aiba valoare 1, dupa valoriile de 'red', 'green' si 'blue' salvate in nodul de arbore din capul cozii. Dupa acestea se adauga in coada toti fii nodului de arbore din capul cozii, apoi, si daca nodul de arbore era diferit sau nu de NULL, se elimina nodul din capul cozii cu 'coadaDequeue' si se trece la urmatorul nod din coada, repetandu-se acest proces pana se iese din while, adica pana cand goala este goala. Dupa ne intoarcem in "main" unde se dezaloca memoria cozii si a arborelui;
	-cerinta 3: se citeste dimensiunea matricii de pixeli care va trebui creata si se aloca memorie pentru aceasta cu "alocMatrice", apoi se aloca memorie penntru radacina arborelui si apoi se aloca memorie pentru coada si se introduce in coada radacina arborelui. Pe urma se intra in functia "decompresion", in care luam o variabila de tip 'Tree' in care salvam radacina arborului, salvata acum in capul cozii. Apoi introducem pe latime in arbore elementele astfel: cat timp coada nu este goala, citim o valoare din fisierul binar direct in nodul de arbore salvat in capul cozii si daca aceasta este 0 atunci initializam fii acelui nod cu "creatTree" si il bagam pe fiecare in parte in coada. Daca valoare ar fi fost 1 atunci citeam valorile 'red', 'green' si 'blue' din fisier si le salvam in nodul de arbore din capul cozii. Cand coada ramane goala inseamna ca nu mai e nimic de citit si putem returna radacina arborelui. Inpoi in main intram in functia "createDecompresionMat" unde cream matricea de pixeli prin prima oara verificand ce fel de nod este. Daca este intern atunci apelam recursiv functia pentru fiecare fiu al nodului, iar daca este extern scriem in matrice pixelii cu functia "scriereMatrice". La finalul fiecarui apel de functie se returneaza matricea rezultata. In main se trece apoi in functia "writeDecompressed" care doar creeaza fisierul binar de tip 'ppm' astfel: prima oara se scrie in el stringul "P6", apoi dimensiune matrice de 2 ori deoarece este patratica, apoi 255 caci aceasta e valoarea maxima pe care o pot avea elementele din fisier si dupa se scrie matrice de pixeli element cu element, fiecare pixel fiind scris sb forma 'red' 'green' si 'blue'. La finalul cerintei se dezaloca memoria matricei, arborelui si cozii.
	In finalul main-ului se inchid fisierele si se returneaza 0. 
